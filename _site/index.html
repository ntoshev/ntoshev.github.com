<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Underengineering &middot; Build more with less
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-50513103-1', 'underengineering.com');
    ga('send', 'pageview');

  </script>

  <script src="/public/js/jquery-1.11.1.min.js"></script>
  <script src="/public/js/jquery.scrolldepth.min.js"></script>
  <script>
    $(function() {
      $.scrollDepth();
    });
  </script>
</head>


  <body class="theme-base-08 layout-reverse">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p><img src="/public/images/niki.jpg" style="height: 90px;width: 90px; border-radius: 50%; -webkit-border-radius: 50%;-moz-border-radius: 50%;"><br />Software engineering with small, orhogonal, composable abstractions. And more.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="/">Home</a>

    

    
    
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
      
    

    <a class="sidebar-nav-item" href="https://github.com/ntoshev/ntoshev.github.com">This blog on GitHub - fork and send pull request to correct something or guest blog!</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Underengineering</a>
            <small>Build more with less</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/07/24/monkey-patching-considered-harmless/">
        Monkey Patching Considered Harmless (When Done Right)
      </a>
    </h1>

    <span class="post-date">24 Jul 2014</span>

    <p>Monkey patching is universally considered a bad practice. Many people avoid having anything to do with it (and with projects that use it, like <a href="http://www.gevent.org/">gevent</a>), without considering if the actual reasons for avoiding it apply to their case. So what are these reasons? I think the important ones are:</p>

<ol>
<li><p>The patched code works very differently from the unpatched, breaking assumptions the rest of the code has about it.</p></li>
<li><p>Monkey patches making assumptions about the code they patch that are implementation detail and change between versions</p></li>
</ol>

<p>(Aside: Most nontrivial errors are about programmer coding wrong assumptions. These can be low level assumptions about how the code behaves or higher level assumptions about the domain that is being modeled.)</p>

<p>Monkey patching is too general so it&#39;s easy to slip into one of these. Note that the same applies about things like inheritance (vs composition). You can avoid these problems with monkey patching if you:</p>

<blockquote>
<p>Write code to monkey patch functions or methods as decorators. Make that decorator general, i.e. assume as little about the modified code as possible. </p>
</blockquote>

<p>It is the second sentence that takes care of the problems above, but it is the decorators that make it possible to write such code (this is not strictly true, any higher order function will do, but decorators provide a nice convention with syntax sugar as an added bonus). We can apply Python decorators on existing functions and methods to permanently modify their behavior. Let&#39;s see how it&#39;s done concretely.</p>

<h2 id="toc_0">Decorators</h2>

<p>If you haven&#39;t actually created decorators, you may think about them as magic syntax sugar and not realize what decorators are actually designed to do is to be functions that take another function as an argument and modify it&#39;s behavior. However, decorators are usually applied at the moment of defining the function they apply to, this is when their special syntax is designed to be used:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div>
<p>Without the syntax sugar, the way to do the same would be (note you can do this also in e.g. Javascript, so this style of monkey patching is available to you in other dynamic languages besides Python):</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</code></pre></div>
<p>If the last line is separate from the function declaration, and the function wasn&#39;t specifically written to be decorated, you will effectively do monkey patching. Some decorators (e.g. doing logging) don&#39;t make any assumptions about the functions they decorate, and the decorated functions could be used without any decorator. Others (like <a href="http://bottlepy.org/docs/0.11/tutorial.html#request-routing">bottlepy&#39;s routing decorators</a> or <code>memoize</code> that you&#39;ll see bellow) make only a few assumptions. </p>

<p>If you do monkey patching with decorators, you avoid the problems with them, because decorators are written to modify the function&#39;s behavior in an orthogonal way. Let&#39;s see a specific real-world example.</p>

<h2 id="toc_1">High volume HTTP requests and DNS resolution</h2>

<p>A common gotcha when writing a crawler is that the bottleneck you will likely hit first is the DNS resolution. I also hit this problem when prototyping <a href="https://t1mr.com">https://t1mr.com</a> (pronounced &#39;timer&#39;, a website availability tool whose basic function is to make an http request to your site every minute and notify you if it&#39;s down). It is weird to diagnose because, depending on your DNS infrastructure, you can get various failures:</p>

<ul>
<li>your home / office router may crash</li>
<li>the DNS infrastructure of your hosting provider may start to return random errors for some of the requests - some timeouts, some other failures (I experienced this with both Hetzner and Amazon EC2)</li>
<li><a href="https://developers.google.com/speed/public-dns/">Google&#39;s Public DNS service</a> would actually behave quite nicely by servicing all your requests, although rate limiting them to 10 resolutions per second.</li>
</ul>

<p>I eventually settled to use Google&#39;s DNS because it&#39;s solid and predictable. But I wanted to make the basic service for t1mr free, so it had to be cheap to run and scale well on a single machine. 10 req/second are just 600 per minute, and I really wanted to saturate the network link.</p>

<p>Normally one would set up a DNS cache on his server and use that. I didn&#39;t quite get this to work (perhaps I exhausted the cache), but I didn&#39;t really try because I wanted maximum control over when and how the domain names are resolved. So how can you implement such a cache in the application?</p>

<p>DNS resolutions are normally handled by the OS. When you open a socket to a remote server specified by name, the  OS blocks that system call and resolves it (unless it is already cached). Resolution can take 100s of milliseconds, that&#39;s why high level frameworks that allow non-blocking code (Python with gevent or node.js) has their own way of doing it (they both use c-ares or blocking OS syscalls in threadpools depending on configuration).</p>

<p>You can modify the http call to use an IP address and set the Host header appropriately. This works, although you have to do it yourself because http libraries typically lack support for it. But in t1mr.com I want to provide checking other types of services besides http, say ICMP ping or SMTP check. The other protocols lack the option to use an IP and specify the domain name separately.</p>

<p>What I did instead was monkey-patch <a href="https://docs.python.org/2/library/socket.html#socket.getaddrinfo"><code>getaddrinfo</code>(the function that resolves domain names)</a> with a memoization decorator. Here is a generic memoizer: </p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="k">def</span> <span class="nf">memoize</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">cache</span>
  <span class="n">cache</span><span class="o">=</span> <span class="p">{}</span>
  <span class="k">def</span> <span class="nf">memf</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
          <span class="n">cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">memf</span>
</code></pre></div>
<p>It is very general and can be used with pretty much any function, like: </p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="nd">@memoize</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
<p>In our case, it is good enough for prototyping. Here is how to monkey-patch <code>socket.getaddrinfo</code> with it:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="kn">import</span> <span class="nn">socket</span>
<span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span> <span class="o">=</span> <span class="n">memoize</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">)</span>
</code></pre></div>
<p>In production we use gevent for efficient networking and a different decorator (that behaves mostly like a cache with expiration). Any networking code will now use under the hood our modified <code>getaddrinfo</code>, resolve the domain name only the first time and use a cached value from now on (until the memoizer decides it is time to refresh).</p>

<p>This might seem like an isolated example where it&#39;s a good idea to patch lower level function, but it&#39;s not.</p>

<h2 id="toc_2">Layered abstractions</h2>

<p>Basically all computing is built on layers upon layers of abstractions. It is considered a good idea to implement a layer relying only upon the layer bellow, and it is. Networks are probably the canonical example. One of the actual limits of this model is that you have to expose the low level abstractions to the high level for tweaking. If you don&#39;t have a mechanism to do this, low level abstractions often leak in a way that is not fixable from the high level code. Monkey patching the lower levels is not a panacea, but it can help here.</p>

<h2 id="toc_3">Conclusion</h2>

<p>Monkey patching is seen as an ugly kludge, but is still used quite a lot because people lack better ways to accomplish their goals using the abstractions available in their language. One way to do safe and useful monkey patching is to write the monkey patch as a decorator, making very few assumptions about the function being decorated, and get a nice orthogonal abstraction in this way.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/05/22/DIY-NoSql/">
        Do It Yourself NoSql
      </a>
    </h1>

    <span class="post-date">22 May 2014</span>

    <p>In this post I will explore the possibility to write <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> web applications without using a relational or nosql database - have the data tier collapse into the application. I&#39;ll show that within certain constraints it is a fast and fun thing to do, very similar to building a prototype, but one that exhibits the characteristics of production-quality software. The resulting architecture is somewhat similar to <a href="http://redis.io/">Redis</a>, except that it would be a (tiny) library instead of a separate server.</p>

<p>The basic idea is simple: have a single process single threaded application. Use a high level language supporting <a href="http://en.wikipedia.org/wiki/Green_threads">green threads</a> with <a href="http://en.wikipedia.org/wiki/Asynchronous_I/O">async I/O</a> (<a href="http://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking">cooperative multitasking</a> within the application) to make it responsive and appear doing multiple things at once, but without the difficulties of real multithreaded programming (no locks or mutexes necessary). Implement simple on-disk persistence.</p>

<p>Let&#39;s see what all this means and how the various pieces of this puzzle fall into places. There are certain assumptions that seem disturbing but can be relaxed with a bit more software infrastructure - notably that the data must fit into memory when represented in the language&#39;s natural data structures. I will use Python, although other stacks can be used with similar effect, notably node.js.</p>

<p>People use databases for query/indexing functionality, persistence and easy concurrent code. Let&#39;s look how we would handle all these.</p>

<h2 id="toc_0">Data model, indexing and queries</h2>

<p>As we&#39;ll keep everything in memory, we&#39;ll just use the language facilities to organize data, modify and query them. This could be a big topic, but I won&#39;t go into much details here. A good way to start would be a structure of nested lists and dicts/hashes that starts from a <code>root</code> variable and can be traversed using normal language syntax. Queries are easily expressed in Python with list comprehensions. Here is an example structure for a web app with registered users, containing mostly login info:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="n">root</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;me@example.com&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">&quot;email&quot;</span><span class="p">:</span> <span class="s">&quot;me@example.com&quot;</span><span class="p">,</span> 
            <span class="s">&quot;salt&quot;</span><span class="p">:</span> <span class="s">&quot;...&quot;</span><span class="p">,</span> 
            <span class="s">&quot;passhash&quot;</span><span class="p">:</span> <span class="s">&quot;...&quot;</span><span class="p">,</span>
            <span class="s">&quot;data&quot;</span> <span class="p">:</span> <span class="p">{},</span>
            <span class="s">&quot;options&quot;</span> <span class="p">:</span> <span class="p">{</span>
                <span class="s">&quot;newsletter&quot;</span><span class="p">:</span> <span class="bp">True</span>
            <span class="p">}</span>
        <span class="p">},</span> 

        <span class="s">&quot;you@example.com&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="o">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>At login attempts you would look up the user&#39;s email address directly in the <code>root</code>, and generally you should structure your data in such a way that you don&#39;t need to iterate in order to find a piece of data. The data structures available in the standard library may not be enough, for example you might need to use something like <a href="https://pypi.python.org/pypi/blist/">blist</a> for ordered collections with fast lookup. You might also want to use dedicated classes instead of generic dicts for your objects (using them with <a href="https://docs.python.org/2/reference/datamodel.html#slots">__slots__</a> would also reduce memory usage).</p>

<p>A query showing the percentage of users who opted in for your newsletter would look like:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="nb">sum</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="s">&#39;options&#39;</span><span class="p">][</span><span class="s">&#39;newsletter&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
</code></pre></div>
<h2 id="toc_1">Easy concurrent code - Atomic, Isolated and Consistent</h2>

<p>Typical web applications are written so that the only shared state resides in the database. It takes care of concurrent access to the shared state - which is what the first three letters from <a href="http://en.wikipedia.org/wiki/ACID">ACID</a> are about. We will keep all data in memory and use event driven architecture (single process, single thread) instead.</p>

<p>In Python I do it with <a href="http://www.gevent.org/">gevent</a>. Gevent lets you write code that does asynchronous network I/O. Node.js is similar, but it uses callbacks while gevent uses coroutines. Many people don&#39;t realize that the code they write with gevent or node.js has very different concurrency properties than the code that uses normal threads. When you use normal threads, you are exposed to race conditions everywhere in your code except where you use explicit concurrency primitives to avoid it. When you use gevent or node.js, there is a single process, so a single address space holding all of your data, and a single thread modifying them. Whenever you do I/O, the context switches to a different green thread (gevent) or different callback (node.js), creating the illusion of parallel execution. But now we can have race conditions only on the I/O boundaries, where execution switches. As long as we don&#39;t have I/O, the code executes as an atomic unit and no one interrupts it.</p>

<h3 id="toc_2">An example: counter</h3>

<p>To make this concrete, consider the example of a global counter implemented with the <a href="http://bottlepy.org/">bottle</a> framework in Python:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="c">#!/usr/bin/python</span>

<span class="kn">import</span> <span class="nn">gevent</span>
<span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span><span class="p">;</span><span class="n">monkey</span><span class="o">.</span><span class="n">patch_all</span><span class="p">()</span>

<span class="c"># hold all global state here</span>
<span class="n">root</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">bottle</span> <span class="kn">import</span> <span class="n">route</span><span class="p">,</span> <span class="n">run</span>

<span class="nd">@route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inc</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="s">&#39;cnt&#39;</span><span class="p">]</span>
    <span class="c"># gevent.sleep is a yield statement, it switches to a different greenlet</span>
    <span class="c"># network I/O would have the same effect</span>
    <span class="c"># uncommenting it will result in incorrect count</span>
    <span class="c">#gevent.sleep() </span>
    <span class="n">root</span><span class="p">[</span><span class="s">&#39;cnt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="s">&quot;Hello World #</span><span class="si">%i</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="n">n</span>

<span class="n">run</span><span class="p">(</span><span class="n">server</span><span class="o">=</span><span class="s">&#39;gevent&#39;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div>
<p>Implemented in native OS threads without synchronization this would result in a race condition, and the counter will be less than the number of requests. With gevent, when you run the code as presented, you get:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">nik@occam:~$ ab -n 1000 -c 10 http://localhost:8080/
[...]
Requests per second:    2555.79 [#/sec] (mean)
</code></pre></div>
<p>Then you can see there is no race condition and the counter is exact. Note that it is also fast, as data are in memory, and there is no locking nor interprocess communication.</p>

<p><img src="/public/images/gevent-concurrency-correct.png" alt="Correct counter"></p>

<p>The commented <code>gevent.sleep(0)</code> line does a &quot;yield&quot;, meaning that the current greenlet pauses and lets other greenlets run (which also happens when you do I/O). For our purposes this is the same as preemption by another thread at this point. If you uncomment it and re-run the test, sure enough, the counter would no longer be correct:</p>

<p><img src="/public/images/gevent-concurrency-wrong.png" alt="Wrong counter"></p>

<p>This basically means that as long as we are conscious about the I/O in our code, we can write multitasking code and reason about it fairly easily. In fact, a CRUD application that doesn&#39;t call external services, would have each HTTP request executed in one piece, with no internal I/O boundaries. </p>

<p>With node.js the I/O boundaries are clearly delineated by callbacks. Everything within a function executes atomically. In gevent the I/O boundaries that matter are just network I/O (disk I/O is blocking in gevent, so it doesn&#39;t cause switching to a different greenlet).</p>

<h3 id="toc_3">ACI</h3>

<p>Let&#39;s ensure we cover the first 3 of the ACID database properties for code between two I/Os:</p>

<ul>
<li><p>Atomicity - all code executes or nothing does. In fact, the system may crash in the middle of our code executing, but this cannot be observed from the client (web browser). If we call external services from our code, they could observe non-atomic behavior.</p></li>
<li><p>Consistency - we only transition between valid states. As long as the system is in valid state at the I/O calls, this property would hold. For a simple CRUD with no external services this means the programmer must make sure it is in valid state at the end of each HTTP request, which should be the case anyway. If our application only reads data from an external service, it should do so in transient variables before starting to modify its state.</p></li>
<li><p>Isolation - the transactions appear to be executed serially, because they are in fact executed serially.</p></li>
</ul>

<p>Before I handle durability in the next section, I want to point out that a nice use case for the technique as presented so far would be implementing a multiplayer poker game - there is plenty of shared server side state, it&#39;s all transient (for the duration of the game), but concurrent updates to the state become easy. It is important not to do too much computation in one chunk as this would increase latency in handling other requests that have come during this time.</p>

<h2 id="toc_4">Durability</h2>

<p>Real durability would make sure application state is fully persisted on disk before returning from an HTTP handler. We&#39;ll do this in a later post, and for now I&#39;ll show how to persist everything every minute or so without breaking the nice properties we have established already. We can call this eventual durability by analogy with eventual consistency :)</p>

<p>Let&#39;s dump a JSON image of the state on disk. In order to produce consistent image, we need to serialize it at once, with no I/O boundary in the middle, and this is the slowest part of the process. Actual writing of the file is an I/O boundary in node.js and synchronous operation with gevent. Here is a simple example that saves the state every minute (you can add this to the counting example above):</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python"><span class="kn">import</span> <span class="nn">tempfile</span><span class="o">,</span> <span class="nn">json</span><span class="o">,</span> <span class="nn">os</span>
<span class="k">def</span> <span class="nf">saveSnapshot</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">doSave</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">fw</span><span class="p">:</span>
           <span class="n">tempname</span> <span class="o">=</span> <span class="n">fw</span><span class="o">.</span><span class="n">name</span>
           <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">fw</span><span class="p">)</span>
           <span class="c"># had to add the following 2 lines to avoid data loss</span>
           <span class="n">fw</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span> <span class="c"># flush any userspace buffers</span>
           <span class="c"># fsync would block the process</span>
           <span class="c"># so run os.fsync(fw.fileno()) in a thread pool</span>
           <span class="n">gevent</span><span class="o">.</span><span class="n">get_hub</span><span class="p">()</span><span class="o">.</span><span class="n">threadpool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">fsync</span><span class="p">,</span> <span class="p">(</span><span class="n">fw</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),))</span> 
           <span class="c"># note fsync is native and doesn&#39;t engage GIL,</span>
           <span class="c"># allowing other code to run</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">tempname</span><span class="p">,</span> <span class="s">&#39;snapshot.json&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">gevent</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
            <span class="n">doSave</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">gevent</span><span class="o">.</span><span class="n">GreenletExit</span><span class="p">:</span>
        <span class="n">doSave</span><span class="p">()</span>
<span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">saveSnapshot</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
</code></pre></div>
<p><del>Note that it doesn&#39;t fsync (guarantee it&#39;s written to disk when the code completes). The write system call returns as soon as the data are in OS&#39;s buffers, so it would be fast. The precise moment the data hit the disk doesn&#39;t matter because the previous snapshot would be available. Data integrity should also be OK because the file system is supposed to take care and do the rename only after it has fully written the file. Nevertheless I&#39;ll provide an fsyncing implementation in a follow up.</del> </p>

<p>Turned out the OS (at least Ubuntu 12.04 with ext4) doesn&#39;t guarantee renaming would happen <em>after</em> the file is written to disk. In fact, it would happily rename the file before committing new snapshot to disk, thus losing the old snapshot. Power loss in this moment leaves you with truncated, unusable snapshot. So I fsync the file here, in gevent&#39;s default threadpool so that I don&#39;t block the main thread from serving requests while it is fsyncing. I don&#39;t fsync the rename operation, but it&#39;s guaranteed rename will happen <em>after</em> writing the snapshot to disk.</p>

<h3 id="toc_5">Scalability bottlenecks</h3>

<p>Here are the bottlenecks you are likely to encounter as you scale the application. I&#39;ll provide guidelines and fixes for them in follow up posts:</p>

<ol>
<li>Snapshot becomes too big to serialize at once</li>
<li>Snapshot becomes too big to fsync to disk at once</li>
<li>State doesn&#39;t fit in RAM</li>
<li>A single core can&#39;t handle all processing</li>
</ol>

<p>An initial implementation using this architecture should be about as expensive as a throwaway prototype, so don&#39;t be afraid to start with it. When you need scale you can rewrite it using anything else with the benefit that you will know more about both your users&#39; problem and how its technical solution should be implemented.</p>

<h2 id="toc_6">Redis comparison</h2>

<p>Redis is built using very similar principles internally: it is single threaded so no complex locking or synchronization is necessary. We have also implemented one of the Redis persistence mechanisms: RDB snapshotting. Redis does the snapshotting somewhat differently: it forks the database process and the parent continues serving requests while the child serializes the data. The memory after fork() is separate, so the new request won&#39;t affect the snapshot in progress. We could do this in Python too (node.js lacks real fork) and avoid blocking the http server while serializing. However, this mechanism works better for Redis than it would in a high level language library. This is because Linux implements the logical separation of memory after fork() using <a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>, so the memory pages are actually shared between the parent and the child until the parent (that continues serving database requests) modifies some of them (at which point the OS produces a separate copy of the modified pages).</p>

<p>This works well in C, but in Python the OS would actually copy the memory of the parent process immediately. This costs CPU and uses twice the memory on snapshotting. Why would the memory split? Because of the automatic memory management in Python, which uses reference counters and stores them with the memory objects. While you traverse the object graph in order to serialize it, you would modify these reference counters and the OS would copy all the memory. This behavior is not unique to Python, the automatic memory management of other high level languages like Ruby interferes with the virtual memory copy-on-write mechanism in a similar way.</p>

<p>What is the difference between writing a Python app using DIY NoSql and a Python app using a Redis back-end? With Redis the data have to cross inter-process boundary to move between the application process and the database process. In fact, they often have to do it multiple times per http request with latencies and CPU usage to serialize/deserialize data adding up. That&#39;s why Redis got Lua scripting - to be able to do application logic close to the data. Actually Redis with scripting is similar to the DIY NoSql architecture, except that now you can use languages other than Lua for scripting and the data storage mechanisms are embedded in the language vs the language being embedded in the data storage mechanisms.</p>

<h2 id="toc_7">Use cases</h2>

<p>There are a couple of public apps running on this architecture.</p>

<h3 id="toc_8">t1mr.com</h3>

<p><a href="https://t1mr.com">t1mr.com</a> is a service that pings your site every minute to verify it is running (and might try to restart it if it&#39;s down and your hosting provider has the API). I wanted the basic functionality to be free so it had to be very efficient. It cycles all the sites every minute, so an in-memory database is a good fit for it. It is network bound and can monitor tens of thousands of sites using a single core.</p>

<h3 id="toc_9">fleetnavi.com</h3>

<p><a href="https://fleetnavi.com">fleetnavi.com</a> is a service that optimizes delivery routes. It solves a vehicle routing problem (a generalization of traveling salesman problem with multiple vehicles, time, capacity and other constraints) using Google Maps data. There are no particular performance constraints requiring the DIY NoSql, but it was the simplest and most flexible option. The optimization solvers run in external processes, so they don&#39;t block the web server.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/04/29/what-underengineering/">
        What underengineering?
      </a>
    </h1>

    <span class="post-date">29 Apr 2014</span>

    <p>A lot of the troubles in software development I&#39;ve seen stem from putting too much structure in your code. Too many layers of indirection, too much meta, too many classes, too much inheritance, too many FactoryFactories. In a series of posts I&#39;ll attempt to show a different way: building small, orthogonal (arbitrary composable) abstractions and using them to do your job with minimal amount of code. The code you write with them should express your intent directly, in the problem domain, not hide it behind some incidental structure of the programming domain. </p>

<p>Here are some examples of beautiful code in Python that are not overengineered:</p>

<ul>
<li><a href="http://norvig.com/">Peter Norvig</a>&#39;s <a href="http://norvig.com/ngrams/">public</a> <a href="http://norvig.com/sudoku.html">code</a> and <a href="https://www.udacity.com/course/cs212">CS212</a></li>
<li><a href="https://github.com/facebook/tornado">Tornado Web Framework</a></li>
<li><a href="https://github.com/defnull/bottle">Bottle</a></li>
</ul>

  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>
</html>
